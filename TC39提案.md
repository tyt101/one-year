关于TC39提案，第一次看，只能说略懂一二。<br />那么就由我这个小白和大家一起浅读TC39，看看近几年(2016-2023)又出了哪些新的API。


<a name="tb6WH"></a>
### 字符串类

---

<a name="stcd7"></a>
#### includes
大家最熟悉的应当是includes了，这个方法既可以用于数组，也可以用于字符串，例如：
:::info
'tangytin'.includes('ytin', 3)   ===> true<br />['tangytin', 'abc', 'guoge'].includes('tangytin')  ===> true<br />[NaN, +0].includes(-0)   ===> true<br />[NaN, +0].includes(NaN)   ===> true
:::
由上述可知，includes方法可以判断NaN和NaN相等，+0和-0相等，实际上includes方法是采用的SameValueZero算法，该算法的特点如下：

- 相同类型原始值， 按 == 比较
- 引用类型， 比较引用指针
- 判断NaN和NaN相等
- 判断+0 和 -0 相等

备注：我们来回顾一下Object.is()和 == 

- Object.is(NaN, NaN) ===> true; Object.is(+0, -0) ===> false
- NaN == NaN ===> false;      +0 == -0 ===> true

<a name="S0rp8"></a>
#### padStart / padEnd
旨在提供更方便的字符串填充功能。 padStart允许在字符串的开头填充空格或其他字符， padEnd允许在字符串的末尾处填充空格或其他字符。 直到字符串达到指定的长度（采用最大长度+第一部分填充）
:::info

- padStart(maxLen, firstFill) / padEnd(maxLen, firstFill)

     	最大长度：指填充后的字符串的MathLen(str) === maxLen<br />     	第一部分填充：指取填充字符的首部开始填充，而不是尾部开始计数填充<br />  

- 举例说明

 	'tang'.padStart(10,'123456789')  ===>  123456tang<br />  'tang'.padEnd(10, '123456789')  ===>  tang123456
:::

<a name="H3Qq1"></a>
#### trimStart / trimEnd
功能与trim类似，而trimStart / trimEnd可以只指定去掉字符串的首部空格/尾部空格。<br />命名与padStart / padEnd统一，trimStart / trimEnd是由 trimLeft / trimRight更改而来。
<a name="DiRLK"></a>
#### well-formed-stringify
旨在扩展JavaScript中的'JSON.stringify'方法， 使其在处理Unicode字符串时更加符合规范。确保生成的JSON字符串在包含特俗字符，控制字符和代理对时仍然有效。
<a name="xKGCg"></a>
#### str.replaceAll(a, b)
看到这个单词replaceAll，想必大家应该能猜到这个函数是用来做什么的了，它就和replace一样，只不过是replace带上/g的全局替代。
<a name="rDFWg"></a>
### 数组类

---

<a name="IyWLf"></a>
#### includes
和上文（字符串类-includes）一致

<a name="iNhbg"></a>
#### Array.prototype.findLast / Array.prototype.findLastIndex
顾名思义，找最后的元素 / 找最后的元素索引。<br />所以这两个方法会从最后一个元素迭代道第一个元素进行搜索。你是否想到了find / findIndex, 是的，findLast / findLastIndex和它们一样，不同之处只在于迭代元素的方向不一致。

<a name="oOcSq"></a>
#### Change Array By Copy 通过复制更改数组
toReversed、toSorted、toSpliced<br />通过复制更改数组，说明当前的数组会被复制，也就是重新拷贝一份，当然在执行逻辑的时候，则会保持目标数组不变，只是返回执行更改后的副本，主要涉及到的方法有以下四个
```markdown
- Array.prototype.toReversed()
- Array.prototype.toSorted(compareFn)
- Array.prototype.toSpliced(start, deleteCount, ...items)
- Array.prototype.with(index, value)	// 在数组中替换指定索引的位置。

上面的几种方法，前三个都有其对应会改变元素组的方法，分别为以下：
- Array.prototype.reversed()
- Array.prototype.sorted(compareFn)
- Array.prototype.spliced(start, deleteCount, ...items)

实际上，我们也可以通过这三种方法自己来实现其所对应的不改变元素组的方法
Array.prototype.toReversed = function() {
  return this.slice().reverse();
};
Array.prototype.toSorted = function(compareFn) {
  return this.slice().sort(compareFn);
};
Array.prototype.toSpliced = function(start, deleteCount, ...items) {
  const copy = this.slice();
  copy.splice(start, deleteCount, ...items);
  return copy;
};
```
<a name="H8vHi"></a>
### 对象类
<a name="M8se7"></a>
#### Object.keys() / Object.values() / Object.entries()
ES2017中引入的特性。这些方法可以更方便的遍历和处理对象的属性。
```markdown
- 我们假定一个对象为obj = { name: 'tyt', age: 18, hobbies: [1,2,3] }
- Object.keys(obj) ===> ['name','age','hobbies']
- Object.values(obj) ===> [ 'tyt', 18, 'hobbies' ]
- Object.entries(obj) ===> [ ['name', 'tyt'], ['age', 18], ['hobbies', [1, 2, 3]] ]
```
<a name="OwK3X"></a>
#### Object.fromEntries()
```markdown
- 可以将数组对象转换成对象, 和Object.entries()是反向操作
- Object.fromEntries([['name', 'tyt'], ['age', 18], ['hobbies', [1, 2, 3]]]) ===> { name: 'tyt', age: 18, hobbies: [1,2,3] }
```
<a name="fI7Gx"></a>
#### Object.getOwnPropertyDescriptors
??
<a name="Fhs7Z"></a>
#### Rest / Spread Properties
Rest / Spread 是在2018年引入的，Rest是用来处理对象/数组的剩余操作，Spread是用来处理对象/数组的展开操作。这两个属性想必在日常开发中会经常使用道，比如在不知道参数个数的情况下，我们用形参...args的方式来接收，这个`...`+标识符args，就是Rest属性，用来收集剩余的属性并把它们放在args中。 而当我们已知，例如obj = { name: 'tyt', age: 18, hobbies: [1,2,3] }，使用`...`+对象，来展开obj，这就是Spread展开属性
```javascript
// Rest:
const { a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 };
console.log(a);     // 1
console.log(b);     // 2
console.log(rest);  // { c: 3, d: 4 }

// Spread:
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 };
console.log(obj2);  // { a: 1, b: 2, c: 3 }
```
<a name="Nr1Iu"></a>
#### Asynchronous Iterators for JavaScript（Javascript的异步迭代器）
"Asynchronous Iterators "旨在扩展Javascript中的迭代器Iterators功能，以支持异步操作。 我们传统的迭代器仅仅支持同步遍历，每次迭代都需要等待当前元素处理完成之后才能继续下一个元素。“Asynchronous Iterators ”的引入，允许我们更自然的去处理异步操作
```markdown
- Symbol.asyncInterator:内置符号，用来定义一个异步迭代器方法，使对象成为异步可迭代。
- 定义一个异步迭代器对象：
  const asyncIterable = {
    async *[Symbol.asyncIterator]() {
      yield new Promise(resolve => setTimeout(() => resolve(1), 1000));
      yield new Promise(resolve => setTimeout(() => resolve(2), 2000));
      yield new Promise(resolve => setTimeout(() => resolve(3), 3000));
    }
  };

  <!-- 异步迭代器对象==》异步迭代器 -->
	const asyncIterator = asyncIterable[Symbol.asyncIterator]();
  <!-- 使用.next()方法开始迭代 -->
	const firstIteration = await asyncIterator.next();
	console.log('firstIteration', firstIteration)
```
<a name="ZJCXi"></a>
#### globalThis
globalThis是浏览器中的一个全局对象，在ES11中定义的，这个属性可以说是方便了多端开发，多平台开发。正常情况下，我们在浏览器中全局是window， 而Nodejs中是global，这个对象globalThis的出现，使我们不再需要去兼容平台，globalThis在浏览器中自动转为window，而在Nodejs中自动转为global

<a name="wdlo9"></a>
#### Object.hasOwn() - 无障碍的Object.prototype.hasOwnProperty()
旨在Object.prototype.hasOwnProperty的无障碍和可读性。总之，以后遇到需要用Object.prototype.hasOwnProperty()的地方就可以都替换成Object.hasOwn().谁叫它是新属性呢？
<a name="YS6o4"></a>
### 正则表达式
<a name="NAVHA"></a>
#### 正则表达式s(dotAll)标志符
<a name="qwuEj"></a>
#### RegExp named capture groups
<a name="XmQxS"></a>
#### RegExp Lookbehind Assertions
<a name="A4dCq"></a>
#### string.prototype.matchAll(reg)
<a name="d1pJB"></a>
### Promise

<a name="g4EmW"></a>
### 其他
<a name="kuqXB"></a>
#### 求幂运算符
:::info
符号：**<br />用法：let a = 3; a**3 = a*a*a = a^3;
:::

**TC39的github链接：**[**https://github.com/tc39/proposals/blob/main/finished-proposals.md**](https://github.com/tc39/proposals/blob/main/finished-proposals.md)**

原型和原型链，new 关键字做了什么？**

**let obj = new func();**

**function func (name) {<br />	this.name = name <br />}<br />func.proptype.say = function (){<br />	console.log('nihao')<br />}

function myNew (fn, ...args) {<br />	 let obj = {}**<br />**   obj.prototo__ = fn.prototype**<br />**   let res = fn.apply(obj, args)<br />	instanceof**<br />**   return typeof res === 'object' ? res : obj**<br />**}**

**myNew(func, 'xixi')  =>  new func('xixi')

**


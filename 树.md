关于数据结构中树的算法，经过做题经验，在我看来，无非就是两种

- 将所有的树都遍历一遍，得出最后的解。
- 树的分解思路，通过树的子树推导出原问题的解。

关于第一种**（将所有的树都遍历一遍，得出最后的解。）**，最直观的理解就是从根节点开始，遍历每一个节点，对这些节点进行一定的处理，最后获得解。让我们来看以下四道题：
<a name="lGl0N"></a>
#### 树的前中后层序遍历
我们已知前序遍历的方式是**“根->左->右”**，所以通过它我们能够很明确的知道应该从根节点开始，依次遍历左子节点直到null，再回溯回去遍历右子节点，因此可以写下如下代码（伪）
```javascript
traverse(root) {

  !root && return 

  // 遍历根
  console.log(root.val)

  // 遍历左
  traverse(root.left)

  // 回溯---遍历右

  traverse(root.right)
}

// 或者

traverse(root) {
  // 利用 栈 先进后出进行遍历
  stack = [root]
  
  while(stack.length) {
    cur = stack.pop()
    // 遍历
    console.log(cur.val)
    // 放入右入栈
    cur.right && stack.push(cur.right)
    // 放入左入栈
  	cur.left && stack.push(cur.left)
  }
}
```
同理，对比中序遍历**(“左->根->右”)**，后序遍历**(“左->右->根”)**也是如此, 层序遍历我们后面说
```javascript
traverse(root){

  !root && return 

  // 遍历左
  traverse(root.left)

  // 遍历根
  console.log(root.val)

  // 遍历右
  traverse(root.right)
  
}

// 或者

traverse(root) {
  let cur = root
  let stack = []

  while( cur || stack.length) {
    
    // 定位到左叶子节点
    while(cur) {
      stack.push(cur)
      cur = cur.left
    }

    // 遍历
    cur = stack.pop()
    console.log(cur.val)

    cur = cur.right
  }
}
```
```javascript
traverse(root) {

  !root && return 

  // 遍历左
  traverse(root.left)

  // 回溯---遍历右

  traverse(root.right)

  // 遍历根
  console.log(root.val)
}

// 或者

traverse(root) {
  // 利用 栈 先进后出进行遍历
  stack = [root]
  
  while(stack.length) {
    cur = stack.pop()
    // 放入右入栈
    cur.right && stack.push(cur.right)
    // 放入左入栈
  	cur.left && stack.push(cur.left)
    // 遍历
    console.log(cur.val)
  }
}
```
最后来说一下层序遍历，层序遍历的过程是针对树的每一层，从左到右依次遍历，这个时候我们只需要关注当前层的节点，并将他们依次输出就可以了，所以我们需要用一个空间来记录当前层有哪些节点，由此就想到了队列结构**(思考🤔：为什么不能用栈结构，队列结构和栈结构有哪些区别)**<br />先直接上代码:
```javascript
traverse(root) {
  !root && return []

  queue = [root]

  // 判断当前层是否为空
  while(queue.length) {
    // 记录len
    len = queue.length
    // 遍历当前层所有节点
    for(i =0; i < len; i++) {
      top = queue.shift()
      console.log(top.val)

      top.left && queue.push(top.left)

      top.right && queue.push(top.right)
    }
    
  }
}
```
那为什么使用栈结构不行，而队列结构可以呢？我相信很多人应该已经看出来了，如果使用栈结构(先进后出)，要达到从左至右遍历当前层， 如果树只有两层【1，2，null，null，3，null，null】，我们交换push进入左右子树的顺序即可了。但是当树超过2层，结构为【1，2，3，4，5】的时候，会发现栈结构一直不断push新节点，当我们取出栈顶时，栈顶节点的层级数已经发生了改变，所以会导致输出的树节点错乱。<br />而队列结构(先进先出)，在我们记录的len长度下，都是该root节点的下一级子节点，所以不会导致层级错乱，自然在一个for循环里输出的节点都是同一层级的节点。

<a name="wBoC9"></a>
#### 树的构造
上面4道题就是经典的树的四种遍历方式，当下已经完全明白了它的遍历过程以及编码实现，下面我们再来看下它的逆序操作，树是如何构造的。当然，树的构造是树的组装过程，基本思路就是构造节点，再构造它的子节点(左，右)，这样一看，这不就是树的分解嘛。同样，我们来看以下三道题：

- 通过前序和中序遍历序列构造二叉树
- 通过中序和后序遍历序列构造二叉树
- 通过前序和后序遍历序列构造二叉树
